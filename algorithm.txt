
'''
some pseudo-python-code that lightly implements the algorithm
'''

#function that reads all segments from file to list
func read_segments(path):
	all_segments = [list of all segments]
	...
	return all_segments

#function that returns all starting segments
#starting segment = segment with only one linking segmet
func find_starter_segments(segments[]):
	answer = []
	for s in segments:
		if (s has only one neighbour):
			answer.add(s)
	return answer

#function that calculates angle between two segments
func angle(s1, s2):
	...
	return angl #in degrees

#function that returns all unpicked neighbours of a given segment
func find_neighbours(segment, all_segments):
    answer = []
    ...
    return answer

#function that returns street list
#each element of that list is a list of segments
#in fact this is the function that solves the problem
func find_streets(all_segments[]):
    list_of_streets = []
    i = 0
    while(all_segments is not empty):
        starts = find_starter_segments(all_segments)
        for start in starts:
            curr = start
            all_segments.delete(start)
            starts.delete(start)
            list_of_streets[i].append(curr)
            while true:
                nghbrs = find_neighbours(curr, all_segments)
                #if we reached some other starter segment
                if(count(nghbrs) == 0):
                    starts.delete(curr)
                    all_segments.delete(curr)
                    break
                
                #if we roll down the street and there is only one way ahead
                if(count(nghbrs) == 1):
                    list_of_streets[i].append(nghbrs[0])
                    all_segments.delete(curr)
                    curr = nghbrs[0] #go to next segment
                
                #if there is a simple crossroads
                if(count(nghbrs) == 2):
                    a0 = angle(curr, nghbrs[0])
                    a1 = angle(curr, nghbrs[1])
                    #a dead end of the streeet
                    if(a0<120 and a1<120):
                        all_segments.delete(curr)
                        break
                    else: #if some of two segments is a continuance of the street
                        if(a0>a1):
                            list_of_streets[i].append(nghbrs[0])
                            all_segments.delete(curr)
                            curr = nghbrs[0]
                        else:
                            list_of_streets[i].append(nghbrs[1])
                            all_segments.delete(curr)
                            curr = nghbrs[1]
                
                #if things are a little complicated...
                if(count(nghbrs) > 2):
                    angles = [tuple(angle(curr, n), n) for n in nghbrs]
                    max_angled_neighbour = ... # find neighbour with maximum angle
                    if(max_angled_neighbour[0] > 130):
                        list_of_streets[i].append(max_angled_neighbour[1])
                        all_segments.delete(curr)
                    else: # if all paths go in too different direction
                        all_segments.delete(curr)
                        break
            
            #increment fo our street list
            i=i+1
    return list_of_streets

#function that colors and outputs result street via png-file
func print_result(street_list[], path):
    ...


#main function
func main():
    segments = read_segments("input/path/file.shp")
    streets = find_streets(segments)
    print_result(streets, "output/path/file.png")